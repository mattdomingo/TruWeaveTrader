package strategy

import (
	"context"
	"time"

	"github.com/TruWeaveTrader/alpaca-tui/internal/alpaca"
	"github.com/TruWeaveTrader/alpaca-tui/internal/models"
	"github.com/TruWeaveTrader/alpaca-tui/internal/risk"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
)

// Strategy defines the interface that all trading strategies must implement
type Strategy interface {
	// Name returns the strategy name
	Name() string

	// Type returns the strategy type (mean_reversion, momentum, pairs_trading, etc.)
	Type() string

	// Initialize sets up the strategy with dependencies
	Initialize(ctx context.Context, client *alpaca.Client, risk *risk.Manager, logger *zap.Logger) error

	// OnTick is called when real-time quote/trade data is received
	OnTick(ctx context.Context, symbol string, data *models.Snapshot) error

	// OnBar is called when a new bar is received (for time-based strategies)
	OnBar(ctx context.Context, symbol string, bar *models.Bar) error

	// OnOrderUpdate is called when an order status changes
	OnOrderUpdate(ctx context.Context, order *models.Order) error

	// OnPositionUpdate is called when a position changes
	OnPositionUpdate(ctx context.Context, position *models.Position) error

	// GetSymbols returns the symbols this strategy trades
	GetSymbols() []string

	// IsActive returns whether the strategy is currently active
	IsActive() bool

	// Start activates the strategy
	Start(ctx context.Context) error

	// Stop deactivates the strategy
	Stop(ctx context.Context) error

	// GetMetrics returns current strategy metrics
	GetMetrics() *StrategyMetrics

	// Shutdown cleanly shuts down the strategy
	Shutdown(ctx context.Context) error
}

// StrategyMetrics holds performance metrics for a strategy
type StrategyMetrics struct {
	TotalTrades     int64           `json:"total_trades"`
	WinningTrades   int64           `json:"winning_trades"`
	LosingTrades    int64           `json:"losing_trades"`
	TotalPnL        decimal.Decimal `json:"total_pnl"`
	MaxDrawdown     decimal.Decimal `json:"max_drawdown"`
	WinRate         float64         `json:"win_rate"`
	AverageWin      decimal.Decimal `json:"average_win"`
	AverageLoss     decimal.Decimal `json:"average_loss"`
	SharpeRatio     float64         `json:"sharpe_ratio"`
	LastTradeTime   time.Time       `json:"last_trade_time"`
	ActivePositions int             `json:"active_positions"`
}

// Signal represents a trading signal generated by a strategy
type Signal struct {
	Strategy   string           `json:"strategy"`
	Symbol     string           `json:"symbol"`
	Action     models.OrderSide `json:"action"` // buy or sell
	Quantity   decimal.Decimal  `json:"quantity"`
	Price      decimal.Decimal  `json:"price"`
	OrderType  models.OrderType `json:"order_type"`
	Reason     string           `json:"reason"`
	Confidence float64          `json:"confidence"` // 0.0 to 1.0
	Timestamp  time.Time        `json:"timestamp"`
	StopLoss   *decimal.Decimal `json:"stop_loss,omitempty"`
	TakeProfit *decimal.Decimal `json:"take_profit,omitempty"`
}

// StrategyConfig holds configuration for a strategy
type StrategyConfig struct {
	Name       string                 `json:"name"`
	Type       string                 `json:"type"`
	Enabled    bool                   `json:"enabled"`
	Symbols    []string               `json:"symbols"`
	Parameters map[string]interface{} `json:"parameters"`
	Schedule   *ScheduleConfig        `json:"schedule,omitempty"`
	RiskLimits *RiskLimits            `json:"risk_limits,omitempty"`
}

// ScheduleConfig defines when a strategy should run
type ScheduleConfig struct {
	StartTime string `json:"start_time"` // "09:30"
	EndTime   string `json:"end_time"`   // "16:00"
	Days      []int  `json:"days"`       // [1,2,3,4,5] for weekdays (Sunday=0)
	Timezone  string `json:"timezone"`   // "America/New_York"
}

// RiskLimits defines strategy-specific risk limits
type RiskLimits struct {
	MaxPositionUSD  *float64 `json:"max_position_usd,omitempty"`
	MaxDailyLossUSD *float64 `json:"max_daily_loss_usd,omitempty"`
	MaxDrawdownPct  *float64 `json:"max_drawdown_pct,omitempty"`
	MaxPositions    *int     `json:"max_positions,omitempty"`
}

// BaseStrategy provides common functionality for all strategies
type BaseStrategy struct {
	name      string
	stratType string
	symbols   []string
	active    bool
	client    *alpaca.Client
	risk      *risk.Manager
	logger    *zap.Logger
	metrics   *StrategyMetrics
	config    *StrategyConfig
	startTime time.Time
}

// NewBaseStrategy creates a new base strategy
func NewBaseStrategy(name, stratType string, symbols []string, config *StrategyConfig) *BaseStrategy {
	return &BaseStrategy{
		name:      name,
		stratType: stratType,
		symbols:   symbols,
		active:    false,
		config:    config,
		metrics: &StrategyMetrics{
			TotalPnL:        decimal.Zero,
			MaxDrawdown:     decimal.Zero,
			AverageWin:      decimal.Zero,
			AverageLoss:     decimal.Zero,
			ActivePositions: 0,
		},
	}
}

// Name returns the strategy name
func (b *BaseStrategy) Name() string {
	return b.name
}

// Type returns the strategy type
func (b *BaseStrategy) Type() string {
	return b.stratType
}

// GetSymbols returns the symbols this strategy trades
func (b *BaseStrategy) GetSymbols() []string {
	return b.symbols
}

// IsActive returns whether the strategy is currently active
func (b *BaseStrategy) IsActive() bool {
	return b.active
}

// Initialize sets up common dependencies
func (b *BaseStrategy) Initialize(ctx context.Context, client *alpaca.Client, risk *risk.Manager, logger *zap.Logger) error {
	b.client = client
	b.risk = risk
	b.logger = logger.With(zap.String("strategy", b.name))
	return nil
}

// Start activates the strategy
func (b *BaseStrategy) Start(ctx context.Context) error {
	b.active = true
	b.startTime = time.Now()
	b.logger.Info("strategy started")
	return nil
}

// Stop deactivates the strategy
func (b *BaseStrategy) Stop(ctx context.Context) error {
	b.active = false
	b.logger.Info("strategy stopped")
	return nil
}

// GetMetrics returns current strategy metrics
func (b *BaseStrategy) GetMetrics() *StrategyMetrics {
	// Calculate win rate
	if b.metrics.TotalTrades > 0 {
		b.metrics.WinRate = float64(b.metrics.WinningTrades) / float64(b.metrics.TotalTrades)
	}
	return b.metrics
}

// UpdateMetrics updates strategy metrics after a trade
func (b *BaseStrategy) UpdateMetrics(pnl decimal.Decimal) {
	b.metrics.TotalTrades++
	b.metrics.TotalPnL = b.metrics.TotalPnL.Add(pnl)
	b.metrics.LastTradeTime = time.Now()

	if pnl.IsPositive() {
		b.metrics.WinningTrades++
		if b.metrics.WinningTrades == 1 {
			b.metrics.AverageWin = pnl
		} else {
			// Running average
			b.metrics.AverageWin = b.metrics.AverageWin.Mul(decimal.NewFromInt(b.metrics.WinningTrades - 1)).Add(pnl).Div(decimal.NewFromInt(b.metrics.WinningTrades))
		}
	} else if pnl.IsNegative() {
		b.metrics.LosingTrades++
		if b.metrics.LosingTrades == 1 {
			b.metrics.AverageLoss = pnl
		} else {
			// Running average
			b.metrics.AverageLoss = b.metrics.AverageLoss.Mul(decimal.NewFromInt(b.metrics.LosingTrades - 1)).Add(pnl).Div(decimal.NewFromInt(b.metrics.LosingTrades))
		}
	}

	// Update max drawdown if necessary
	if pnl.IsNegative() && pnl.LessThan(b.metrics.MaxDrawdown) {
		b.metrics.MaxDrawdown = pnl
	}
}

// LogSignal logs a trading signal
func (b *BaseStrategy) LogSignal(signal *Signal) {
	b.logger.Info("signal generated",
		zap.String("symbol", signal.Symbol),
		zap.String("action", string(signal.Action)),
		zap.String("quantity", signal.Quantity.String()),
		zap.String("price", signal.Price.String()),
		zap.String("reason", signal.Reason),
		zap.Float64("confidence", signal.Confidence),
	)
}

// CheckSchedule returns true if the strategy should be active based on schedule
func (b *BaseStrategy) CheckSchedule() bool {
	if b.config.Schedule == nil {
		return true // No schedule means always active
	}

	now := time.Now()

	// Check if today is in allowed days (use schedule timezone if provided)
	loc := time.Local
	if b.config.Schedule.Timezone != "" {
		if tz, err := time.LoadLocation(b.config.Schedule.Timezone); err == nil {
			loc = tz
		}
	}

	today := now.In(loc)
	dayAllowed := false
	for _, day := range b.config.Schedule.Days {
		if int(today.Weekday()) == day {
			dayAllowed = true
			break
		}
	}

	if !dayAllowed {
		return false
	}

	// Check time range in the specified timezone
	startTime, err := time.ParseInLocation("15:04", b.config.Schedule.StartTime, loc)
	if err != nil {
		return true // Invalid time format, assume always active
	}

	endTime, err := time.ParseInLocation("15:04", b.config.Schedule.EndTime, loc)
	if err != nil {
		return true // Invalid time format, assume always active
	}

	currentTime, _ := time.ParseInLocation("15:04", today.Format("15:04"), loc)

	return currentTime.After(startTime) && currentTime.Before(endTime)
}
